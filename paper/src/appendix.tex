\appendix
\chapter{付録}

\section{付録内容}
周回時各地点での位置補正に要した秒数のデータ\ref{log_data}
\begin{lstlisting}[caption=log\_data.csv,label=log_data]
    index,start_time,end_time,diff
    1,1580193930.29,1580193976.28,-45.9868371487
    2,1580193990.3,1580193994.3,-4.00511908531
    3,1580194009.33,1580194013.32,-3.98436999321
    4,1580194028.36,1580194032.34,-3.97335982323
    5,1580194035.4,1580194039.46,-4.06102204323
    6,1580194052.82,1580194068.8,-15.9791119099
    7,1580194083.81,1580194087.82,-4.00577402115
    8,1580194102.83,1580194118.84,-16.0141539574
    9,1580194132.9,1580194144.87,-11.9710979462
    1,1580196624.09,1580196667.6,-43.5060019493
    2,1580196681.69,1580196685.71,-4.02595710754
    3,1580196701.1,1580196721.41,-20.3125030994
    4,1580196736.47,1580196740.43,-3.9612288475
    5,1580196753.45,1580196757.45,-4.00381112099
    6,1580196772.49,1580196776.47,-3.97698187828
    7,1580196791.52,1580196795.49,-3.97074103355
    8,1580196809.54,1580196813.51,-3.97161698341
    9,1580196820.23,1580196823.28,-3.04999995231
    1,1580198671.04,1580198714.29,-43.2508609295
    2,1580198728.31,1580198732.31,-4.00313401222
    3,1580198747.38,1580198751.33,-3.95450305939
    4,1580198766.39,1580198782.36,-15.9714820385
    5,1580198795.41,1580198799.38,-3.97379899025
    6,1580198814.42,1580198818.4,-3.97790408134
    7,1580198833.42,1580198837.42,-3.99298119545
    8,1580198851.44,1580198879.46,-28.0157217979
    9,1580198892.49,1580198896.47,-3.98590183258
    1,1580199262.13,1580199304.84,-42.7095551491
    2,1580199318.89,1580199339.25,-20.359513998
    3,1580199354.6,1580199358.56,-3.96238017082
    4,1580199373.89,1580199377.88,-3.99445414543
    5,1580199390.94,1580199403.26,-12.3130421638
    6,1580199418.3,1580199422.28,-3.97520399094
    7,1580199437.29,1580199441.3,-4.00463104248
    8,1580199455.35,1580199471.63,-16.2756249905
    9,1580199484.76,1580199505.0,-20.2366819382
    1,1580200356.27,1580200450.39,-94.1180570126
    2,1580200464.46,1580200468.41,-3.9505751133
    3,1580200483.44,1580200504.44,-21.0034091473
    4,1580200519.51,1580200523.46,-3.94975781441
    5,1580200536.52,1580200556.56,-20.0388579369
    6,1580200571.89,1580200591.89,-20.0021989346
    7,1580200606.94,1580200610.91,-3.96967601776
    8,1580200624.94,1580200628.93,-3.98880791664
    9,1580200641.97,1580200645.94,-3.97123003006
    1,1580201161.0,1580201187.53,-26.5303680897
    2,1580201201.89,1580201213.86,-11.9634230137
    3,1580201228.91,1580201244.89,-15.9810349941
    4,1580201259.92,1580201290.93,-31.0086560249
    5,1580201303.94,1580201344.98,-41.0400719643
    6,1580201360.04,1580201380.02,-19.974052906
    7,1580201395.07,1580201399.04,-3.96285891533
    8,1580201413.05,1580201438.38,-25.3258821964
    9,1580201451.45,1580201455.4,-3.94306898117
    1,1580202744.16,1580202809.66,-65.5057330132
    2,1580202823.73,1580202872.72,-48.9925370216
    3,1580202887.75,1580202899.75,-12.0069699287
    4,1580202914.78,1580202918.77,-3.99462604523
    5,1580202932.11,1580202936.09,-3.98409891129
    6,1580202951.16,1580202975.13,-23.9704370499
    7,1580202990.18,1580202994.15,-3.97114396095
    8,1580203008.22,1580203012.17,-3.95584893227
    9,1580203025.2,1580203029.19,-3.98650503159
    1,1580204346.96,1580204422.06,-75.0941159725
    2,1580204436.1,1580204440.07,-3.97245383263
    3,1580204455.13,1580204475.1,-19.9742369652
    4,1580204490.15,1580204494.12,-3.97111201286
    5,1580204507.18,1580204531.16,-23.9756538868
    6,1580204546.19,1580204550.18,-3.9876408577
    7,1580204565.24,1580204577.2,-11.9651100636
    8,1580204591.27,1580204595.22,-3.94821619987
    9,1580204608.29,1580204612.24,-3.94957995415
    1,1580208884.14,1580208939.61,-55.4682879448
    2,1580208953.66,1580208957.63,-3.9718708992
    3,1580208972.67,1580209012.05,-39.3805930614
    4,1580209027.07,1580209031.07,-4.00029397011
    5,1580209044.09,1580209064.1,-20.0068509579
    6,1580209079.15,1580209083.12,-3.97090888023
    7,1580209098.15,1580209110.15,-11.9959571362
    8,1580209124.18,1580209128.17,-3.98279809952
    9,1580209141.19,1580209153.19,-11.999601841
    1,1580210529.13,1580210583.77,-54.6374969482
    2,1580210598.11,1580210602.09,-3.97895812988
    3,1580210617.11,1580210653.44,-36.3331010342
    4,1580210668.5,1580210672.46,-3.96202206612
    5,1580210685.52,1580210745.52,-60.0027010441
    6,1580210760.61,1580210788.6,-27.9818811417
    7,1580210803.65,1580210807.62,-3.96309781075
    8,1580210821.63,1580210825.71,-4.08048391342
    9,1580210839.02,1580210843.02,-4.00416183472
\end{lstlisting}

今回実験に使用したスクリプト\ref{controller}
\begin{lstlisting}[caption=controller.py,label=controller]
#!/usr/bin/env python
# -*- coding:utf-8 -*-
import threading
import time
import numpy as np
import json

import cv2


class Controller(object):
    def __init__(self, drone):
        # init objs
        self.drone = drone
        self.thread = None
        self.stopEvent = None
        self.QR_SIZE = 14.2
        self.UNIT_SIZE = 2.4
        self.RAD_UNIT = 180/3.14
        self.SPEED = 10
        self.Z_SPACE = 85
        self.permit_noise = 10
        self.COMMAND_WAIT_BUFFER = 3
        self.objp = np.array([
            [[0, 0, 0]],
            [[self.QR_SIZE/self.UNIT_SIZE, 0, 0]],
            [[self.QR_SIZE/self.UNIT_SIZE, self.QR_SIZE/self.UNIT_SIZE, 0]],
            [[0, self.QR_SIZE/self.UNIT_SIZE, 0]]
        ], dtype="float32")
        self.axis = np.float32([
            [self.QR_SIZE/self.UNIT_SIZE, 0, 0],
            [0, self.QR_SIZE/self.UNIT_SIZE, 0],
            [0, 0, -1 * self.QR_SIZE/self.UNIT_SIZE]
        ]).reshape(-1, 3)
        self.mtx = np.load("tello_mtx.npy")
        self.dist = np.load("tello_dist.npy")
        self.count = 1
        self.fourcc = cv2.VideoWriter_fourcc(*'XVID')
        self.out = cv2.VideoWriter('default.avi',
                                   self.fourcc, 20.0, (960, 720))
        self.is_moving = False
        self.is_standby = False
        self.target_pos = {
            'x': 0,
            'y': 0,
            'z': 0,
            'r': 0
        }
        self.drone_rotate_list = []
        self.drone_pos_list = []
        self.drone_pos = {
            'x': 0,
            'y': 0,
            'z': 0,
            'r': 0
        }
        self.log_data = {}

        # init methods
        self.stopEvent = threading.Event()
        self.thread = threading.Thread(target=self.video_loop)
        self.thread.start()
        self.send_command_thread = \
            threading.Thread(target=self._sending_command)
        self.send_command_thread.start()
        self.drone.set_speed(self.SPEED)
        self.drone.takeoff()
        time.sleep(7)
        self.main()

    def __del__(self):
        self.drone.land()
        self.out.release()
        time.sleep(3)
        self.stopEvent.set()

    def video_loop(self):
        try:
            time.sleep(0.5)
            while not self.stopEvent.is_set():
                frame = self.drone.read()
                if frame is None or frame.size == 0:
                    continue
                self.pnp_qr(frame)
        except(KeyboardInterrupt, SystemExit):
            self.stopEvent.set()
            print('exit video loop')

    def _sending_command(self):
        while not self.stopEvent.is_set():
            self.drone.send_command('command')
            print('battery: ', self.drone.get_battery())
            time.sleep(5)

    def draw(self, img, corners, imgpts):
        try:
            corner = tuple(corners[0].ravel())
            img = cv2.line(img, corner, tuple(
                imgpts[0].ravel()), (255, 0, 0), 5)
            img = cv2.line(img, corner, tuple(
                imgpts[1].ravel()), (0, 255, 0), 5)
            img = cv2.line(img, corner, tuple(
                imgpts[2].ravel()), (0, 0, 255), 5)
            return img
        except Exception:
            return img

    def _qr_validator(self, data):
        x = data['x'] if 'x' in data else 0
        y = data['y'] if 'y' in data else 0
        z = data['z'] if 'z' in data else 0
        r = data['rotate'] if 'rotate' in data else 0
        return {'x': x, 'y': y, 'z': z, 'r': r }

    def pnp_qr(self, frame):
        img = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)

        qr = cv2.QRCodeDetector()
        data, points, _ = qr.detectAndDecode(img)
        if data:
            self.qr_data = self._qr_validator(json.loads(data))
            _, origin_rvec, origin_tvec, inliers = cv2.solvePnPRansac(
                self.objp, points, self.mtx, self.dist)
            if not self.is_moving:
                self.target_pos = self.qr_data
                tvec = origin_tvec * self.UNIT_SIZE
                rvec = origin_rvec * self.RAD_UNIT
                self.drone_pos_list.append(tvec)
                self.drone_rotate_list.append(rvec)
                if len(self.drone_pos_list) > 20:
                    self.drone_pos_list.pop(0)
                    self.drone_rotate_list.pop(0)
                drone_avg_pos = np.mean(self.drone_pos_list, axis=(0))
                drone_avg_rotate = np.mean(self.drone_rotate_list, axis=(0))
                self.drone_pos = {
                    'x': drone_avg_pos[0],
                    'y': drone_avg_pos[1],
                    'z': drone_avg_pos[2],
                    'r': drone_avg_rotate[1]
                }
            imgpts, jac = cv2.projectPoints(
                self.axis, origin_rvec, origin_tvec, self.mtx, self.dist)
            img = self.draw(img, points, imgpts)

            cv2.imshow('img', img)
            cv2.waitKey(10)
        else:
            cv2.imshow('img', img)
            cv2.waitKey(10)
        if not self.count in self.log_data:
            self.log_data[self.count] = time.time()
        self.out.write(img)

    def close_to_qr(self):
        print('self pos: ', self.drone_pos)
        move_x_val = int(self.drone_pos["x"] - (self.QR_SIZE/2))
        move_y_val = int(self.drone_pos["y"] - (self.QR_SIZE/2))
        move_z_val = int(self.drone_pos["z"] - self.Z_SPACE)
        rotate_val = int(self.drone_pos["r"])
        move_data = {
            "x": move_x_val,
            "y": move_y_val,
            "z": move_z_val,
            "r": rotate_val
        }
        self._move(move_data)
        return

    def go_to_target(self):
        print('self pos: ', self.drone_pos)
        move_data = {
            "x": self.target_pos["x"],
            "y": -self.target_pos["y"],
            "z": self.target_pos["z"],
            "r": self.target_pos["r"]
        }
        self.count += 1
        self.log_data[self.count] = time.time()
        with open('log_data.csv',"a") as f:
            f.write(str(self.count/2)+","+str(self.log_data[self.count-1])+","+str(self.log_data[self.count])+","+str(self.log_data[self.count-1]-self.log_data[self.count])+"\n")
        self._move(move_data)
        self.count += 1
        self.target_pos = {
            'x': 0,
            'y': 0,
            'z': 0,
            'r': 0
        }
        return

    def _move(self, data):
        self.is_moving = True
        # move x
        if data["x"] >= 10:
            self.drone.move_right(data["x"])
            time.sleep(data["x"]/self.SPEED + self.COMMAND_WAIT_BUFFER)
            print('sleep x: ', data["x"]/self.SPEED +
                  self.COMMAND_WAIT_BUFFER)
        elif data["x"] <= -10:
            self.drone.move_left(-data["x"])
            time.sleep(-data["x"]/self.SPEED + self.COMMAND_WAIT_BUFFER)
            print('sleep x: ', -data["x"]/self.SPEED +
                  self.COMMAND_WAIT_BUFFER)
        # move y
        if data["y"] >= 10:
            self.drone.move_down(data["y"])
            time.sleep(data["y"]/self.SPEED + self.COMMAND_WAIT_BUFFER)
            print('sleep y: ', data["y"]/self.SPEED +
                  self.COMMAND_WAIT_BUFFER)
        elif data["y"] <= -10:
            self.drone.move_up(-data["y"])
            time.sleep(-data["y"]/self.SPEED + self.COMMAND_WAIT_BUFFER)
            print('sleep y: ', -data["y"]/self.SPEED +
                  self.COMMAND_WAIT_BUFFER)
        # move z
        if data["z"] >= 10:
            self.drone.move_forward(data["z"])
            time.sleep(data["z"]/self.SPEED + self.COMMAND_WAIT_BUFFER)
            print('sleep z: ', data["z"]/self.SPEED +
                  self.COMMAND_WAIT_BUFFER)
        elif data["z"] <= -10:
            self.drone.move_backward(-data["z"])
            time.sleep(-data["z"]/self.SPEED + self.COMMAND_WAIT_BUFFER)
            print('sleep z: ', -data["z"]/self.SPEED +
                  self.COMMAND_WAIT_BUFFER)
        # rotate r
        if data["r"] > 0:
            self.drone.rotate_cw(data["r"])
        else:
            self.drone.rotate_ccw(-data["r"])
        time.sleep(self.COMMAND_WAIT_BUFFER)
        # initialize values
        self.is_moving = False
        self.is_standby = False
        self.drone_pos_list = []
        self.drone_rotate_list = []
        return

    def check_standby(self):
        x_val = int(self.drone_pos["x"] - (self.QR_SIZE/2))
        y_val = int(self.drone_pos["y"] - (self.QR_SIZE/2))
        z_val = int(self.drone_pos["z"] - self.Z_SPACE)
        rotate_val = int(self.drone_pos["r"])
        self.is_standby = -self.permit_noise < x_val and self.permit_noise > x_val and \
            -self.permit_noise < y_val and self.permit_noise > y_val and \
            -self.permit_noise < z_val and self.permit_noise > z_val and \
            -self.permit_noise < rotate_val and self.permit_noise > rotate_val
        print('check: ', x_val, y_val, z_val, rotate_val)
        print('is_standby: ', self.is_standby)


    def main(self):
        # main thread
        # main thread is sending command and waiting for keyboardInterrupt
        try:
            while True:
                self.close_to_qr()
                self.check_standby()
                time.sleep(1)
                if self.is_standby:
                    self.go_to_target()
                if self.count == 100:
                    break
        except(KeyboardInterrupt, SystemExit):
            self.__del__()
            print("exit")
        self.__del__()
\end{lstlisting}